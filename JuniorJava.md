# **Java Core**

## **Типы данных в Java**
* boolean - true/false
* byte - -128 до 127, 1 байт
* short - (+/-)3276(7/8), 2 байта
* int - (+/-)214748364(7/8), 4 байта
* long - (+/-)9 223 372 036 854 775 80(7/8), 8 байт
* double - с плавающей точкой, 8 байт
* float - с плавающей точкой, 4 байта
* char - символ в кодировке UTF-16 (0 до 65535), 2 байта


## **Отличия объекта от примитивных типов данных**
* примитивные типы выигрывают в производительности и занимаемой памяти
* 


## **Разница передачи параметров по ссылке и по значению**
*Передача по значению (by value)* - значения фактических параметров копируются. Вызываемый метод создает свою копию значений аргументов и затем ее использует. Поскольку работа ведется с копией, на исходный параметр это никак не влияет.

*Передача по ссылке (by reference)* - параметры передаются как ссылка (адрес) на исходную переменную. Вызываемый метод не создает свою копию, а ссылается на исходное значение. Следовательно, изменения, сделанные в вызываемом методе, также будут отражены в исходном значении.

    Java всегда передает параметры по значению! Однако ссылки указывают на один и тот же объект в куче (heap), что приводит к изменениям параметра даже во внешних методах.


## **Bytecode**
Все ЯП можно условно разделить на компилируемые и интерпретируемые. В Java используется третий подход — байт-код. Исходный код Java преобразуется компилятором в байт-код (а не машинный код). A байт-код Java преобразуется в машинный код с помощью специального интерпретатора - JVM.

## **JVM, JDK, JRE**
*JVM (Java Virtual Machine)* - виртуальная машина отвечает за само выполнение кода. Она работает с байткодом (тем, что находится внутри файлов с расширением .class).

*JRE (Java Runtime Environment)* - окружение, необходимое для запуска Java-программ. Включает в себя стандартную библиотеку. В нее входят, как базовые пакеты lang, util, так и пакеты для работы с различными форматами, БД, пользовательским интерфейсом. JVM тоже часть JRE.

*JDK (Java Development Kit)* - набор программ для разработки. Включает в себя JRE, загрузчик кода java, компилятор javac, архиватор jar, генератор документации javadoc и другие утилиты, нужные во время разработки.


## **Признаки JavaBean**
1. Все свойства приватные (для доступа геттеры/сеттеры)
2. Открытый конструктор без аргументов
3. Реализует Serializable


## **OutOfMemoryError**
Ошибка возникающая при недостатке физической памяти для выделения приложению. Из-за чего приложением падает без информации в логах или потоке вывода о том где и почему это произошло.


## **Стектрейс и как его получить**
Stacktrace (стек вызовов) - последовательность вызовов функций в программе.
```java
StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();
    for (StackTraceElement element : stackTraceElements)
    {
       System.out.println(element.getMethodName());
    }
```


## **Все методы класса object**
```java
//Возвращает строковое представление объекта
public String toString()

//Используются для сравнения объектов
public native int hashCode()
public boolean equals(Object obj)

//Возвращает специальный объект, который описывает текущий класс
public final native Class getClass()

//Методы для контроля доступа к объекту из различных нитей/потоков(threads). Управление синхронизацией нитей
public final native void notify()
public final native void notifyAll()
public final native void wait(long timeout)
public final void wait(long timeout, intnanos)
public final void wait()

//Позволяет «освободить» родные не-Java ресурсы: закрыть файлы, потоки и т.д.
protected void finalize()

//Позволяет клонировать объект: создает дубликат объекта
protected native Object clone()
```


## **Отличие между try-with-resources и try-catch-finally**
try-with-resources аналог традиционного и подробного блока try-catch-finally. Реализация ресурса должна выполняться в try(). Ресурсы автоматически закрываются после try(), вместо ручного закрытия в блоке finally в try-catch-finally.
```java
try (FileReader fileReader = new FileReader("D:\\test.txt");) {
    ...
}
catch (IOException e){
      e.printStackTrace();
}
```


## **Конструкторы и их типы**
1. *Конструктор по умолчанию* - не описанный в классе явно, а созданный автоматически компилятором.

2. *Конструктор без аргументов*
```java
public BankAccount() {
    name = "";
    opened = LocalDateTime.now();
    balance = 0.0d;
}
```
3. *Параметризованный конструктор*
```java
public BankAccount(String name, LocalDateTime opened, double balance) {
    this.name = name;
    this.opened = opened;
    this.balance = balance;
}
```
*Конструктор копирования* - специальный конструктор, который применяется когда необходимо создать копию сложного объекта, но при этом мы не хотим использовать метод clone().
*Связанные конструкторы* - один конструктор вызывает другой из этого же класса.


## **Побитовые операции**
*Поразрядные операции* - выполняются над отдельными двоичными разрядами или битами чисел. В данных операциях в качестве операндов могут выступать только целые числа.
**Логические операции**:
* & (логическое И / умножение) - если у обоих операндов значения разрядов равно 1, то операция возвращает 1, иначе возвращается число 0
* | (логическое ИЛИ / сложение) - возвращается единица, если хотя бы у одного числа в данном разряде имеется единица
* ^ (логическое исключающее ИЛИ / XOR) - Если у нас значения текущего разряда у обоих чисел разные, то возвращается 1, иначе возвращается 0
* ~ (логическое отрицание) - инвертирует все разряды числа: если значение разряда равно 1, то оно становится 0


## **Краткая характеристика immutable object и зачем они нужны**
*Иммутабельный (неизменяемый/immutable) объект*  — объект, который после инициализации не может изменить свое состояние. То есть если в коде есть ссылка на экземпляр иммутабельного класса, то любые изменения в нем приводят к созданию нового экземпляра. Иммутабельность позволяет строить более стабильные программы и ее принципы зачастую применимы в фундаментальных частях софта.


## **Требования для создания immutable класса**
* Объявлен как final, чтобы от него нельзя было наследоваться. Иначе дочерние классы могут нарушить иммутабельность.
* Все поля класса должны быть приватными в соответствии с принципами инкапсуляции.
* Должны быть параметризованные конструкторы для корректного создания экземпляра, через которые осуществляется первоначальная инициализация полей класса.
* В классе не должно быть сеттеров, для исключения возможности изменения состояния после инстанцирования
* Для полей-коллекций необходимо делать глубокие копии, чтобы гарантировать их неизменность.


## **Объекты каких стандартных классов immutable в Java**
* String
* Все классы-обертки над примитивными типами (Boolean, Integer, Byte, Long..)
* BigInteger и BigDecimal
* Объекты класса java.lang.StackTraceElement
* File
* UUID
* Объекты классов пакета java.time
* Locale


## **Преимущества immutable object перед обычными объектами**
* Потокобезопасность - можно свободно использовать одновременно из разных нитей.
* Являются хорошими ключами в map.
* Отлично подходят для хранения констант.
* “Атомарность по отношению к сбою” — если immutable объект выбросит исключение, то он всё равно не останется в нежелательном (сломанном) состоянии.
* Просты в реализации и тестировании
* Не нужны такие дополнительные механизмы как конструктор копирования и реализация клона.


